    const CONFIG = { API_URL: localStorage.getItem('api_url') || '', CACHE_TTL: 30000, MAX_RETRIES: 3, TIMEOUT: 10000, DEBOUNCE_DELAY: 500};window.onerror = function(msg, url, line, col, error) { console.error('‚ùå –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞:', { msg, url, line, error }); fetch(`${CONFIG.API_URL}/api/log`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: msg, stack: error?.stack, url, line, timestamp: Date.now() }) }).catch(() => {}); showToast('–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –Ω–æ –º—ã —É–∂–µ —á–∏–Ω–∏–º', 'error'); return true;};async function fetchWithTimeout(url, options = {}) { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), CONFIG.TIMEOUT); try { const response = await fetch(url, { ...options, signal: controller.signal }); clearTimeout(timeoutId); return response; } catch (error) { clearTimeout(timeoutId); if (error.name === 'AbortError') { throw new Error('–¢–∞–π–º–∞—É—Ç –∑–∞–ø—Ä–æ—Å–∞'); } throw error; }}async function fetchWithRetry(url, options = {}, retries = CONFIG.MAX_RETRIES) { for (let i = 0; i < retries; i++) { try { const response = await fetchWithTimeout(url, options); if (!response.ok) { throw new Error(`HTTP ${response.status}`); } return await response.json(); } catch (error) { console.warn(`–ü–æ–ø—ã—Ç–∫–∞ ${i + 1} –Ω–µ —É–¥–∞–ª–∞—Å—å:`, error.message); if (i === retries - 1) { throw error; } await new Promise(r => setTimeout(r, 1000 * Math.pow(2, i))); } }}const cache = new Map();function getCached(key) { const item = cache.get(key); if (!item) return null; if (Date.now() - item.timestamp > CONFIG.CACHE_TTL) { cache.delete(key); return null; } return item.data;}function setCached(key, data) { cache.set(key, { data, timestamp: Date.now() });}async function fetchWithCache(url, options = {}, cacheKey = url) { const cached = getCached(cacheKey); if (cached) { console.log('üì¶ –ò—Å–ø–æ–ª—å–∑—É—é –∫—ç—à –¥–ª—è:', cacheKey); return cached; } try { const data = await fetchWithRetry(url, options); setCached(cacheKey, data); return data; } catch (error) { const oldCache = cache.get(cacheKey); if (oldCache) { console.warn('‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É—é —É—Å—Ç–∞—Ä–µ–≤—à–∏–π –∫—ç—à'); return oldCache.data; } throw error; }}const eventListeners = new Map();function addManagedListener(element, event, handler) { if (!eventListeners.has(element)) { eventListeners.set(element, []); } element.addEventListener(event, handler); eventListeners.get(element).push({ event, handler });}function removeAllListeners(element) { const listeners = eventListeners.get(element); if (listeners) { listeners.forEach(({ event, handler }) => { element.removeEventListener(event, handler); }); eventListeners.delete(element); }}const timers = new Set();function setManagedTimeout(callback, delay) { const id = setTimeout(() => { timers.delete(id); callback(); }, delay); timers.add(id); return id;}function setManagedInterval(callback, interval) { const id = setInterval(callback, interval); timers.add(id); return id;}function clearAllTimers() { timers.forEach(id => { clearTimeout(id); clearInterval(id); }); timers.clear();}window.addEventListener('beforeunload', () => { clearAllTimers(); document.querySelectorAll('[data-managed]').forEach(removeAllListeners);});function debounce(func, delay = CONFIG.DEBOUNCE_DELAY) { let timeoutId; return function(...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() => func.apply(this, args), delay); };}function memoize(func, resolver = (...args) => JSON.stringify(args)) { const cache = new Map(); return function(...args) { const key = resolver(...args); if (cache.has(key)) { console.log('üìã –ò—Å–ø–æ–ª—å–∑—É—é –º–µ–º–æ–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç'); return cache.get(key); } const result = func.apply(this, args); cache.set(key, result); return result; };}function showToast(message, type = 'info') { const container = document.getElementById('toast-container'); if (!container) return; const toast = document.createElement('div'); toast.className = `toast ${type}`; toast.textContent = message; container.appendChild(toast); setTimeout(() => { toast.remove(); }, 3000);}window.API = { fetch: fetchWithCache, fetchWithRetry, fetchWithTimeout};window.utils = { debounce, memoize, showToast};window.core = { setManagedTimeout, setManagedInterval, addManagedListener, removeAllListeners, clearAllTimers};window.CONFIG = CONFIG;
